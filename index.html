<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Тренажёр арабских слов — выбор ответа (POS-aware)</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;margin:20px;color:#111;background:#fff}
  #main{max-width:900px;margin:0 auto}
  .hidden{display:none}
  .button{padding:10px 14px;margin:8px 6px;font-size:1rem;cursor:pointer;border-radius:6px;border:1px solid #bbb;background:#f6f6f6}
  h1{font-size:2rem;margin-bottom:6px}
  #progress{margin:12px 0;color:#333}
  #arabic-word{font-size:2.2rem;padding:18px;background:#fff;border-radius:8px;border:1px solid #eee;text-align:right;direction:rtl;margin:8px 0}
  .choices{display:flex;flex-direction:column;gap:14px;margin-top:14px}
  .choice-btn{padding:18px;border-radius:12px;border:1px solid #e0e0e0;background:#fff;font-size:1.6rem;text-align:center;cursor:pointer}
  .choice-btn.correct{background:#d9f7e0;border-color:#8ad39f}
  .choice-btn.wrong{background:#ffdede;border-color:#ff8a8a}
  #lists{display:flex;gap:20px;margin-top:18px;flex-wrap:wrap}
  #correct-list,#mistake-list{flex:1 1 320px;min-height:80px;background:#fafafa;padding:10px;border-radius:6px;border:1px solid #eee;max-height:240px;overflow:auto}
  textarea{width:100%;height:140px;padding:8px;font-size:1rem}
  input[type="text"]{padding:8px;font-size:1rem}
  .controls-row{margin-top:12px}
  .small{font-size:0.95rem;color:#666}
  .overlay{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.38);display:flex;align-items:center;justify-content:center;z-index:10000;padding:20px}
  .modal{background:#fff;border-radius:8px;padding:22px;max-width:820px;width:100%;box-shadow:0 6px 30px rgba(0,0,0,0.25)}
  .modal h2{margin:0 0 8px;font-size:26px}
  .modal .label{font-size:16px;margin-bottom:8px}
  .modal .answer{font-weight:700;font-size:22px;direction:rtl;text-align:right}
  .modal .controls{display:flex;justify-content:flex-end;margin-top:14px}
  .close-btn{padding:8px 12px;border-radius:6px;border:1px solid #bbb;background:#f4f4f4;cursor:pointer}
  @media(max-width:560px){ .choice-btn{font-size:1.25rem;padding:14px} #arabic-word{font-size:1.8rem} }
</style>
</head>
<body>
  <div id="main">
    <h1>Арабский тренажёр (выбор)</h1>

    <div id="loader">
      <p class="small">Вставьте список слов (формат: перевод(ы) через запятую - арабская_форма1 - арабская_форма2). Примеры:</p>
      <pre class="small">жаловаться - اِشْتَكَى - يَشْتَكِي
раз - مَرّةٌ - مَرّاتٌ
дитя, ребенок - وَلَدٌ</pre>

      <textarea id="text-input" placeholder="каждая строка — одно слово с форматом: перевод(ы) - арабская_форма1 - арабская_форма2"></textarea>

      <div class="controls-row">
        <button id="load-list" class="button">Загрузить список вручную</button>
        <button id="fetch-github" class="button">Загрузить из words.txt</button>
        <span id="count" class="small"></span>
      </div>

      <p class="small">Файл <code>words.txt</code> должен лежать в той же папке, что и <code>index.html</code> (корень репозитория GitHub Pages).</p>
    </div>

    <div id="controls" class="hidden">
      <button id="start-all" class="button">Начать тренировку</button>
      <button id="start-mistakes" class="button hidden">Работа над ошибками</button>
      <button id="reset-btn" class="button">Пройти заново</button>
    </div>

    <div id="trainer" class="hidden">
      <div id="progress"></div>
      <div id="arabic-word" aria-live="polite"></div>

      <div class="choices" id="choices">
        <button class="choice-btn" id="opt0"></button>
        <button class="choice-btn" id="opt1"></button>
        <button class="choice-btn" id="opt2"></button>
      </div>

      <div id="lists">
        <div>
          <h3>Правильно:</h3>
          <div id="correct-list">—</div>
        </div>
        <div>
          <h3>Ошибки:</h3>
          <div id="mistake-list">—</div>
        </div>
      </div>

      <div id="after-session" class="hidden" style="margin-top:14px">
        <button id="finish-retry" class="button">Пройти заново (всю сессию)</button>
        <button id="go-mistakes" class="button hidden">Работать над ошибками</button>
      </div>
    </div>
  </div>

  <div id="modal-root"></div>

<script>
/* ======= Логика с POS-aware distractors ======= */
let allWords = [];      // { arabicFull, rusVariants:[], rawLine, pos }
let sessionWords = [];
let mistakes = [];
let corrects = [];
let currentIndex = 0;
let modalTimer = null;

const textInput = document.getElementById('text-input');
const loadListBtn = document.getElementById('load-list');
const fetchGithubBtn = document.getElementById('fetch-github');
const countP = document.getElementById('count');
const controls = document.getElementById('controls');
const startAllBtn = document.getElementById('start-all');
const startMistakesBtn = document.getElementById('start-mistakes');
const resetBtn = document.getElementById('reset-btn');

const trainer = document.getElementById('trainer');
const progressDiv = document.getElementById('progress');
const arabicWordH2 = document.getElementById('arabic-word');
const optButtons = [document.getElementById('opt0'), document.getElementById('opt1'), document.getElementById('opt2')];

const correctListDiv = document.getElementById('correct-list');
const mistakeListDiv = document.getElementById('mistake-list');

const afterSession = document.getElementById('after-session');
const finishRetry = document.getElementById('finish-retry');
const goMistakesBtn = document.getElementById('go-mistakes');

loadListBtn.addEventListener('click', () => {
  const text = textInput.value;
  if(!text.trim()) return alert('Вставьте список слов.');
  parseText(text);
  countP.textContent = `Загружено слов: ${allWords.length}`;
  controls.classList.remove('hidden');
  startMistakesBtn.classList.add('hidden');
});

fetchGithubBtn.addEventListener('click', () => {
  fetch('words.txt').then(resp => {
    if(!resp.ok) throw new Error(`Ошибка: ${resp.status}`);
    return resp.text();
  }).then(text => {
    textInput.value = text;
    parseText(text);
    countP.textContent = `Загружено слов: ${allWords.length}`;
    controls.classList.remove('hidden');
    startMistakesBtn.classList.add('hidden');
    alert('words.txt успешно загружен.');
  }).catch(err => {
    console.error(err);
    alert('Не удалось загрузить words.txt. Убедитесь, что файл существует.');
  });
});

/* == POS detection (по русским переводам) ==
   Простая эвристика: если какой-то перевод заканчивается на типичные глагольные суффиксы -> verb, иначе noun.
*/
function detectPOS(rusVars){
  const verbEndings = ['ться','ться','ть','ить','еть','ать','овать','нуть','ять','тись','иться','оваться'];
  for(const v of rusVars){
    const s = v.toLowerCase().trim();
    for(const e of verbEndings){
      if(s.endsWith(e)) return 'verb';
    }
  }
  // fallback: если есть запятая и слова вроде "делать" -> verb; но проще: noun
  return 'noun';
}

function parseText(text){
  allWords = text.split(/\r?\n/).map(l => l.trim()).filter(l => l).map(line => {
    const sep = line.search(/[-–—]/);
    const rusPart = sep !== -1 ? line.slice(0, sep).trim() : '';
    const arabPart = sep !== -1 ? line.slice(sep+1).trim() : '';
    const rusVars = rusPart ? rusPart.split(',').map(r => r.trim()).filter(r=>r) : [''];
    const arabFull = arabPart;
    const pos = detectPOS(rusVars); // добавляем pos
    return { arabicFull: arabFull, rusVariants: rusVars, rawLine: line, pos };
  });
}

/* утилиты */
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
function chooseRandomDifferentIndexes(total, avoidIndex, count){
  const idxs = [];
  for(let i=0;i<total;i++) if(i!==avoidIndex) idxs.push(i);
  shuffle(idxs);
  return idxs.slice(0,count);
}

/* ===== Новая логика выбора дистракторов по POS =====
   findDistractorsByPOS(correctIndex, count) -> возвращает массив индексов
   Сначала ищем кандидатов той же pos, сортируем по совпадению токенов в переводах (похожесть),
   затем берём верхние. Если не хватает — дополняем случайными элементами.
*/
function findDistractorsByPOS(correctIndex, count){
  const correct = allWords[correctIndex];
  if(!correct) return chooseRandomDifferentIndexes(allWords.length, correctIndex, count);
  // собрать кандидатов той же пос
  const candidates = [];
  for(let i=0;i<allWords.length;i++){
    if(i===correctIndex) continue;
    if(allWords[i].pos === correct.pos) candidates.push(i);
  }
  // если нет кандидатов той же POS — fallback на любые
  if(candidates.length === 0){
    return chooseRandomDifferentIndexes(allWords.length, correctIndex, count);
  }
  // score по числу совпадающих токенов
  const correctTokens = correct.rusVariants.join(' ').toLowerCase().split(/\W+/).filter(Boolean);
  const scored = candidates.map(i => {
    const tokens = allWords[i].rusVariants.join(' ').toLowerCase().split(/\W+/).filter(Boolean);
    let score = 0;
    for(const t of tokens) if(correctTokens.includes(t)) score++;
    return { i, score };
  });
  // сортируем по убыванию score
  scored.sort((a,b) => b.score - a.score);
  const picks = [];
  for(const s of scored){
    if(picks.length >= count) break;
    picks.push(s.i);
  }
  // если не хватило — заполнить случайными кандидатами той же POS (без повторов)
  shuffle(candidates);
  for(const c of candidates){
    if(picks.length >= count) break;
    if(!picks.includes(c)) picks.push(c);
  }
  // если всё ещё мало — дополняем любыми случайными
  if(picks.length < count){
    const more = chooseRandomDifferentIndexes(allWords.length, correctIndex, count - picks.length);
    for(const m of more) if(!picks.includes(m)) picks.push(m);
  }
  return picks.slice(0, count);
}

/* === сессии и UI === */
startAllBtn.addEventListener('click', ()=> startSession(false));
startMistakesBtn.addEventListener('click', ()=> {
  if(mistakes.length===0){ alert('Список ошибок пуст.'); return; }
  startSession(true);
});
resetBtn.addEventListener('click', ()=> startSession(false));

function startSession(useMistakes=false){
  corrects = [];
  if(!useMistakes){
    mistakes = [];
    sessionWords = allWords.slice();
  } else {
    sessionWords = mistakes.slice();
    mistakes = [];
  }
  shuffle(sessionWords);
  currentIndex = 0;
  correctListDiv.innerHTML = '';
  mistakeListDiv.innerHTML = '';
  controls.classList.add('hidden');
  trainer.classList.remove('hidden');
  afterSession.classList.add('hidden');
  showNext();
}

function showNext(){
  clearChoiceStyles();
  if(currentIndex >= sessionWords.length){
    progressDiv.textContent = `Готово! Пройдено ${sessionWords.length}/${sessionWords.length}, ошибок: ${mistakes.length}`;
    afterSession.classList.remove('hidden');
    finishRetry.classList.remove('hidden');
    goMistakesBtn.classList.toggle('hidden', mistakes.length===0);
    return;
  }
  const item = sessionWords[currentIndex];
  arabicWordH2.textContent = item.arabicFull || '[нет арабского]';
  progressDiv.textContent = `${currentIndex+1}/${sessionWords.length} слов пройдено – ${mistakes.length} ошибок`;

  // подготовка вариантов: 1 верный (все переводы), 2 неверных (подбор по POS)
  const correctText = item.rusVariants.join(', ');
  // находим индекс этого item в allWords (по rawLine)
  let mainIndex = allWords.findIndex(a => a.rawLine === item.rawLine);
  if(mainIndex === -1){
    mainIndex = allWords.findIndex(a => a.arabicFull === item.arabicFull && a.rusVariants.join(',') === item.rusVariants.join(','));
  }
  const wrongIdxs = findDistractorsByPOS(mainIndex === -1 ? 0 : mainIndex, 2);

  const wrongTexts = [];
  for(let i=0;i<wrongIdxs.length;i++){
    const it = allWords[wrongIdxs[i]];
    wrongTexts.push(it ? it.rusVariants.join(', ') : correctText);
  }
  while(wrongTexts.length < 2) wrongTexts.push(correctText);

  const options = [correctText, wrongTexts[0], wrongTexts[1]];
  shuffle(options);

  optButtons.forEach((btn, idx) => {
    btn.textContent = options[idx] || '';
    btn.disabled = false;
    btn.classList.remove('correct','wrong');
    btn.dataset.correct = (options[idx] === correctText) ? '1' : '0';
  });
}

function clearChoiceStyles(){ optButtons.forEach(b => { b.classList.remove('correct','wrong'); b.disabled = false; }); }

optButtons.forEach(btn => {
  btn.addEventListener('click', (e) => {
    const chosen = e.currentTarget;
    const isCorrect = chosen.dataset.correct === '1';
    optButtons.forEach(b => b.disabled = true);
    if(isCorrect){
      chosen.classList.add('correct');
      const cur = sessionWords[currentIndex];
      correctListDiv.innerHTML = (correctListDiv.innerHTML.trim()==='—' ? '' : correctListDiv.innerHTML) + `<div>${escapeHtml(cur.arabicFull)} → ${escapeHtml(cur.rusVariants.join(', '))}</div>`;
      currentIndex++;
      setTimeout(()=> showNext(), 700);
    } else {
      chosen.classList.add('wrong');
      const cur = sessionWords[currentIndex];
      mistakes.push(cur);
      mistakeListDiv.innerHTML = (mistakeListDiv.innerHTML.trim()==='—' ? '' : mistakeListDiv.innerHTML) + `<div>${escapeHtml(cur.arabicFull)} → ${escapeHtml(cur.rusVariants.join(', '))}</div>`;
      showWrongModal(cur.arabicFull, cur.rusVariants.join(', '), () => {
        currentIndex++;
        showNext();
      });
    }
  });
});

function showWrongModal(arabicText, ruText, onClose){
  closeModal();
  const root = document.getElementById('modal-root');
  const overlay = document.createElement('div'); overlay.className = 'overlay';
  const modal = document.createElement('div'); modal.className = 'modal';
  modal.innerHTML = `<h2>Неправильно</h2>
    <div class="label">Правильный ответ:</div>
    <div class="answer">${escapeHtml(arabicText)} — ${escapeHtml(ruText)}</div>
    <div class="controls"><button id="modal-close-btn" class="close-btn">Закрыть (Esc)</button></div>`;
  overlay.appendChild(modal);
  root.appendChild(overlay);
  function cleanup(){ if(modalTimer){ clearTimeout(modalTimer); modalTimer = null; } document.removeEventListener('keydown', onKey); const btn = document.getElementById('modal-close-btn'); if(btn) btn.removeEventListener('click', onBtn); if(overlay.parentNode) overlay.parentNode.removeChild(overlay); }
  function onKey(e){ if(e.key === 'Escape'){ cleanup(); if(typeof onClose==='function') onClose(); } }
  function onBtn(){ cleanup(); if(typeof onClose==='function') onClose(); }
  document.addEventListener('keydown', onKey);
  const btn = document.getElementById('modal-close-btn'); if(btn) btn.addEventListener('click', onBtn);
  modalTimer = setTimeout(()=>{ cleanup(); if(typeof onClose==='function') onClose(); }, 17000);
}
function closeModal(){ const root = document.getElementById('modal-root'); root.innerHTML=''; if(modalTimer){ clearTimeout(modalTimer); modalTimer=null; } }
finishRetry.addEventListener('click', ()=> { startSession(false); });
goMistakesBtn.addEventListener('click', ()=> { if(mistakes.length===0) alert('Ошибок нет'); else startSession(true); });
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

</script>
</body>
</html>
