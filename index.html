<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Арабский тренажёр — исправлено</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;margin:18px;color:#111;background:#fff}
  #container{max-width:980px;margin:0 auto}
  .hidden{display:none}
  .button{padding:8px 12px;margin:6px;font-size:1rem;cursor:pointer;border-radius:6px;border:1px solid #bbb;background:#f6f6f6}
  h1{font-size:1.6rem;margin:6px 0}
  #progress{margin:12px 0;color:#333}
  #arabic-word{
    font-size:3rem;
    padding:18px 14px;
    background:#fff;
    border-radius:10px;
    border:1px solid #eee;
    text-align:center;
    direction:rtl;
    line-height:1.05;
    white-space:normal;
    word-break:break-word;
    min-height:3.6em;
    font-family: "Noto Naskh Arabic", "Arial", "Tahoma", "Segoe UI", system-ui, sans-serif;
  }
  .choices{display:flex;flex-direction:column;gap:12px;margin-top:12px}
  .choice-btn{padding:14px;border-radius:10px;border:1px solid #e0e0e0;background:#fff;font-size:1.35rem;text-align:center;cursor:pointer}
  .choice-btn.correct{background:#d9f7e0;border-color:#8ad39f}
  .choice-btn.wrong{background:#ffdede;border-color:#ff8a8a}
  #lists{display:flex;gap:20px;margin-top:18px;flex-wrap:wrap}
  #correct-list,#mistake-list{flex:1 1 320px;min-height:80px;background:#fafafa;padding:10px;border-radius:6px;border:1px solid #eee;max-height:280px;overflow:auto}
  textarea{width:100%;height:120px;padding:8px;font-size:1rem}
  .small{font-size:0.95rem;color:#666}
  .overlay{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.38);display:flex;align-items:center;justify-content:center;z-index:10000;padding:20px}
  .modal{background:#fff;border-radius:8px;padding:22px;max-width:820px;width:100%;box-shadow:0 6px 30px rgba(0,0,0,0.25)}
  .modal h2{margin:0 0 8px;font-size:22px}
  .modal .answer{font-weight:700;font-size:20px;direction:rtl;text-align:right}
  @media(max-width:560px){
    #arabic-word{font-size:2.2rem;padding:12px}
    .choice-btn{font-size:1.1rem;padding:12px}
  }
</style>
</head>
<body>
  <div id="container">
    <h1>Тренажёр арабских слов</h1>

    <div id="intro">
      <p>Дуа:</p>
      <blockquote style="direction:rtl;font-size:1.8rem;margin:8px 0">رَّبِّ زِدْنِى عِلْمًۭا</blockquote>
      <p>«Господь мой! Приумножь мои знания»</p>
      <button id="did-dua" class="button">Я сделал дуа</button>
    </div>

    <div id="loader" class="hidden" style="margin-top:12px">
      <p class="small">Вставьте/подгрузите список слов (формат: перевод(ы) - арабская_форма1 - арабская_форма2)</p>
      <textarea id="text-input" placeholder="пример: жаловаться - اِشْتَكَى - يَشْتَكِي"></textarea>
      <div style="margin-top:8px">
        <button id="load-manual" class="button">Загрузить вручную</button>
        <button id="fetch-file" class="button">Загрузить из words.txt</button>
        <span id="count" class="small"></span>
      </div>
    </div>

    <div id="trainer" class="hidden" style="margin-top:14px">
      <div id="progress">0/0 слов пройдено – 0 ошибок</div>
      <div id="arabic-word" aria-live="polite"></div>

      <div class="choices" id="choices">
        <button class="choice-btn" id="opt0"></button>
        <button class="choice-btn" id="opt1"></button>
        <button class="choice-btn" id="opt2"></button>
      </div>

      <div style="margin-top:10px">
        <button id="add-new-btn" class="button">Добавить новые слова</button>
        <button id="reset-progress-btn" class="button">Сбросить прогресс</button>
        <button id="copy-mistakes-btn" class="button">Копировать ошибки</button>
      </div>

      <div id="lists">
        <div>
          <h3>Правильно:</h3>
          <div id="correct-list">—</div>
        </div>
        <div>
          <h3>Ошибки:</h3>
          <div id="mistake-list">—</div>
        </div>
      </div>

      <div id="after" class="hidden" style="margin-top:14px">
        <button id="retry-all" class="button">Пройти заново</button>
        <button id="work-mistakes" class="button hidden">Работа над ошибками</button>
      </div>
    </div>
  </div>

  <div id="modal-root"></div>

<script>
/* ========== Конфиг ========== */
const STORAGE_KEY = (() => {
  const p = (location.pathname||'/').replace(/^\/|\/$/g,'').replace(/\//g,'_') || 'root';
  return `arabic_trainer_state_v1_${encodeURIComponent(location.hostname + '_' + p)}`;
})();
const AUTO_MODAL_CLOSE_MS = 17000;

/* ========== Утилиты ========== */
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* ========== Состояния ========== */
let allWords = [];      // { rawLine, arabicFull, rusVariants[], pos }
let orderRaw = [];      // remaining rawLine'ы (не показаны ещё)
let currentRaw = null;  // текущая rawLine (показанная)
let mistakes = [];      // rawLine[]
let corrects = [];      // rawLine[]
let mode = 'all';       // 'all' или 'mistakes'

/* ========== DOM ========== */
const didDuaBtn = document.getElementById('did-dua');
const loader = document.getElementById('loader');
const textInput = document.getElementById('text-input');
const loadManualBtn = document.getElementById('load-manual');
const fetchFileBtn = document.getElementById('fetch-file');
const countSpan = document.getElementById('count');

const trainer = document.getElementById('trainer');
const progressDiv = document.getElementById('progress');
const arabicWordDiv = document.getElementById('arabic-word');
const optButtons = [document.getElementById('opt0'), document.getElementById('opt1'), document.getElementById('opt2')];

const addNewBtn = document.getElementById('add-new-btn');
const resetProgressBtn = document.getElementById('reset-progress-btn');
const copyMistakesBtn = document.getElementById('copy-mistakes-btn');

const correctListDiv = document.getElementById('correct-list');
const mistakeListDiv = document.getElementById('mistake-list');

const afterDiv = document.getElementById('after');
const retryAllBtn = document.getElementById('retry-all');
const workMistakesBtn = document.getElementById('work-mistakes');

const modalRoot = document.getElementById('modal-root');

/* ========== Парсер / нормализация ========== */
function normalizeLine(line){
  if(!line) return '';
  line = line.replace(/^\uFEFF/, '');
  line = line.replace(/[\u2010\u2011\u2012\u2013\u2014\u2015–—−]/g, '-');
  line = line.replace(/\u00A0/g,' ');
  line = line.replace(/\s+/g,' ').trim();
  return line;
}

function detectPOS(rusVars){
  const verbEndings = ['ться','ть','ить','еть','ать','овать','нуть','ять','тись','иться','оваться','ся'];
  for(const v of rusVars){
    const s = v.toLowerCase().trim();
    for(const e of verbEndings) if(s.endsWith(e)) return 'verb';
  }
  return 'noun';
}

function improvedParseText(text){
  text = (text||'').replace(/^\uFEFF/,'');
  const rawLines = text.split(/\r?\n/);
  const parsed = [];
  const skipped = [];
  for(let i=0;i<rawLines.length;i++){
    const raw = rawLines[i];
    const line = normalizeLine(raw);
    if(!line) continue;
    const sep = line.indexOf('-');
    if(sep === -1){
      skipped.push({index:i+1, raw:line});
      continue;
    }
    const left = line.slice(0, sep).trim();
    const right = line.slice(sep+1).trim();
    const rusVars = left ? left.split(',').map(s=>s.trim()).filter(Boolean) : [''];
    const arabicFull = right;
    parsed.push({ rawLine: line, arabicFull, rusVariants: rusVars, pos: detectPOS(rusVars) });
  }
  return { parsed, skipped };
}

/* ========== robust fetch ========== */
async function robustFetchWords(){
  const tries = ['words.txt','./words.txt'];
  try{ tries.push(location.pathname.replace(/\/[^/]*$/,'/') + 'words.txt'); }catch(e){}
  for(const p of tries){
    try{
      const r = await fetch(p);
      if(r.ok) return await r.text();
    }catch(e){}
  }
  try{
    const user = location.hostname.split('.')[0] || '';
    const repo = (location.pathname.split('/').filter(Boolean)[0] || '');
    if(user && repo){
      const raw = `https://raw.githubusercontent.com/${user}/${repo}/main/words.txt`;
      const r2 = await fetch(raw);
      if(r2.ok) return await r2.text();
    }
  }catch(e){}
  throw new Error('Не удалось загрузить words.txt автоматически');
}

/* ========== Save / Load state (rawLine-based) ========== */
function saveState(){
  try{
    const st = {
      allRaw: allWords.map(w=>w.rawLine),
      orderRaw: orderRaw.slice(),
      currentRaw,
      mistakesRaw: mistakes.slice(),
      correctsRaw: corrects.slice(),
      mode
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(st));
  }catch(e){ console.error('saveState', e); }
}

function loadState(){ try{ const raw = localStorage.getItem(STORAGE_KEY); return raw ? JSON.parse(raw) : null; }catch(e){ return null; } }

function parseSingleLineToObj(line){
  const { parsed } = improvedParseText(line);
  return parsed && parsed[0] ? parsed[0] : null;
}

/* ========== Init / Restore logic (rawLine-based sync) ========== */
function restoreStateAfterLoad(){
  const st = loadState();
  if(!st) return false;
  // ensure allWords contains all lines from saved snapshot
  const map = new Map(allWords.map(w=>[w.rawLine,w]));
  for(const r of st.allRaw || []) if(!map.has(r)){
    const obj = parseSingleLineToObj(r);
    if(obj){ allWords.push(obj); map.set(r,obj); }
  }
  // restore orderRaw (remaining), but filter by current server allWords
  const serverRawSet = new Set(allWords.map(w=>w.rawLine));
  orderRaw = (Array.isArray(st.orderRaw) ? st.orderRaw.slice() : []).filter(r => serverRawSet.has(r));
  // if server has new lines not in snapshot, append them to orderRaw (so new words will be asked)
  const oldSnap = Array.isArray(st.allRaw) ? new Set(st.allRaw) : new Set([]);
  const toAdd = allWords.map(w=>w.rawLine).filter(r => !oldSnap.has(r));
  for(const r of toAdd){
    if(!orderRaw.includes(r) && r !== st.currentRaw && !st.correctsRaw?.includes(r) && !st.mistakesRaw?.includes(r)) orderRaw.push(r);
  }
  // restore mistakes/corrects filtered by server
  mistakes = (Array.isArray(st.mistakesRaw) ? st.mistakesRaw.filter(r => serverRawSet.has(r)) : []);
  corrects = (Array.isArray(st.correctsRaw) ? st.correctsRaw.filter(r => serverRawSet.has(r)) : []);
  currentRaw = (st.currentRaw && serverRawSet.has(st.currentRaw)) ? st.currentRaw : null;
  mode = st.mode || 'all';
  return true;
}

/* ========== Helpers for UI ========== */
function updateProgress(){
  const total = allWords.length;
  const done = total - orderRaw.length;
  progressDiv.textContent = `${done}/${total} слов пройдено – ${mistakes.length} ошибок`;
}

function renderLists(){
  correctListDiv.innerHTML = corrects.length ? corrects.map(c=>`<div>${escapeHtml(c)}</div>`).join('') : '—';
  mistakeListDiv.innerHTML = mistakes.length ? mistakes.map(c=>`<div>${escapeHtml(c)}</div>`).join('') : '—';
}

/* ========== Order management & showing words (non-repeat) ========== */
function prepareOrder(source='all'){
  if(source === 'all'){
    orderRaw = allWords.map(w=>w.rawLine);
    shuffle(orderRaw);
    mode = 'all';
  } else {
    // mistakes mode
    orderRaw = mistakes.slice();
    shuffle(orderRaw);
    mode = 'mistakes';
  }
  saveState();
}

function nextWord(){
  // if no remaining -> prepare
  if(!orderRaw || orderRaw.length === 0){
    if(mode === 'mistakes' && mistakes.length === 0){
      arabicWordDiv.textContent = 'Ошибок нет.';
      updateProgress();
      return;
    }
    prepareOrder(mode === 'mistakes' ? 'mistakes' : 'all');
  }
  if(orderRaw.length === 0){
    arabicWordDiv.textContent = 'Нет слов для тренировки.';
    updateProgress();
    return;
  }
  // take next (shift -> removed from remaining immediately)
  const raw = orderRaw.shift();
  currentRaw = raw;
  saveState(); // persist immediately so it won't repeat on reload

  const obj = allWords.find(w => w.rawLine === raw) || parseSingleLineToObj(raw) || { rawLine: raw, arabicFull: raw, rusVariants: [''] };
  // display arabic
  let displayArabic = (obj.arabicFull || '').trim();
  if(!displayArabic){
    const sep = raw.indexOf('-');
    if(sep !== -1) displayArabic = raw.slice(sep+1).trim();
  }
  displayArabic = displayArabic.replace(/\s*-\s*/g,' - ').trim();
  arabicWordDiv.textContent = displayArabic || '[нет арабского]';
  arabicWordDiv.setAttribute('dir','rtl');

  // prepare options: show full rusVariants as comma-separated for the correct option
  const correctText = (obj.rusVariants||[]).join(', ') || '(нет перевода)';
  const distractors = findDistractorsFor(obj, 2);
  const options = [correctText, (distractors[0]?.rusVariants||[]).join(', ') || '—', (distractors[1]?.rusVariants||[]).join(', ') || '—'];
  shuffle(options);
  optButtons.forEach((btn,idx) => {
    btn.textContent = options[idx] || '';
    btn.disabled = false;
    btn.classList.remove('correct','wrong');
    btn.dataset.correct = (options[idx] === correctText) ? '1' : '0';
  });
  updateProgress();
  renderLists();
}

/* find distractors by pos then fallback */
function findDistractorsFor(correctObj, count){
  const same = allWords.filter(w => w.pos === correctObj.pos && w.rawLine !== correctObj.rawLine);
  shuffle(same);
  const picks = same.slice(0,count);
  if(picks.length < count){
    const others = allWords.filter(w => w.rawLine !== correctObj.rawLine && !picks.includes(w));
    shuffle(others);
    for(const o of others){
      if(picks.length>=count) break;
      picks.push(o);
    }
  }
  while(picks.length < count) picks.push(correctObj);
  return picks.slice(0,count);
}

/* ========== Option button handlers ========== */
optButtons.forEach(btn => {
  btn.addEventListener('click', (e) => {
    const chosen = e.currentTarget;
    const isCorrect = chosen.dataset.correct === '1';
    optButtons.forEach(b=>b.disabled=true);
    const curRaw = currentRaw;
    const obj = allWords.find(w => w.rawLine === curRaw) || parseSingleLineToObj(curRaw) || { rawLine: curRaw, arabicFull: curRaw, rusVariants: [''] };
    if(isCorrect){
      chosen.classList.add('correct');
      // store full rawLine into corrects for display (user asked full raw)
      corrects.push(obj.rawLine);
      renderLists();
      saveState();
      // short delay so user sees highlight
      setTimeout(()=> {
        currentRaw = null;
        if(orderRaw.length === 0) finishSession(); else nextWord();
      }, 450);
    } else {
      chosen.classList.add('wrong');
      // add to mistakes as rawLine but avoid duplicates
      if(!mistakes.includes(obj.rawLine)) mistakes.push(obj.rawLine);
      renderLists();
      saveState();
      // show modal with correct raw and rus variants; after close -> next
      const correctText = obj.rawLine;
      showWrongModal(obj.arabicFull || obj.rawLine, (obj.rusVariants||[]).join(', '), ()=> {
        currentRaw = null;
        if(orderRaw.length === 0) finishSession(); else nextWord();
      });
    }
  });
});

/* ========== Modal (17s auto-close) ========== */
let modalTimer = null;
function showWrongModal(arabicText, ruText, onClose){
  closeModal();
  const overlay = document.createElement('div'); overlay.className='overlay';
  const modal = document.createElement('div'); modal.className='modal';
  modal.innerHTML = `<h2>Неправильно</h2><div class="label">Правильный ответ:</div><div class="answer">${escapeHtml(arabicText)} — ${escapeHtml(ruText)}</div><div style="text-align:right;margin-top:12px"><button id="modal-close-btn" class="button">Закрыть (Esc)</button></div>`;
  overlay.appendChild(modal); modalRoot.appendChild(overlay);
  function cleanup(){ if(modalTimer){ clearTimeout(modalTimer); modalTimer=null; } document.removeEventListener('keydown', onKey); const b=document.getElementById('modal-close-btn'); if(b) b.removeEventListener('click', onBtn); if(overlay.parentNode) overlay.parentNode.removeChild(overlay); }
  function onKey(e){ if(e.key==='Escape'){ cleanup(); if(typeof onClose==='function') onClose(); } }
  function onBtn(){ cleanup(); if(typeof onClose==='function') onClose(); }
  document.addEventListener('keydown', onKey);
  const btn = document.getElementById('modal-close-btn'); if(btn) btn.addEventListener('click', onBtn);
  modalTimer = setTimeout(()=>{ cleanup(); if(typeof onClose==='function') onClose(); }, AUTO_MODAL_CLOSE_MS);
}
function closeModal(){ modalRoot.innerHTML=''; if(modalTimer){ clearTimeout(modalTimer); modalTimer=null; } }

/* ========== Finish session ========== */
function finishSession(){
  const total = allWords.length || 0;
  const done = total - (orderRaw.length || 0);
  arabicWordDiv.textContent = `Готово! Пройдено ${done}/${total}, ошибок: ${mistakes.length}`;
  afterDiv.classList.remove('hidden');
  workMistakesBtn.classList.toggle('hidden', mistakes.length === 0);
  saveState();
  renderLists();
}

/* ========== Add new words (only truly new) ========== */
async function addNewWords(){
  try{
    const txt = await robustFetchWords();
    const { parsed } = improvedParseText(txt);
    const existingSet = new Set(allWords.map(w=>w.rawLine));
    let added = 0;
    for(const p of parsed){
      if(!existingSet.has(p.rawLine) && !corrects.includes(p.rawLine) && !mistakes.includes(p.rawLine)){
        allWords.push(p);
        // append to orderRaw only if not present
        if(!orderRaw.includes(p.rawLine) && p.rawLine !== currentRaw) orderRaw.push(p.rawLine);
        added++;
        existingSet.add(p.rawLine);
      }
    }
    countSpan.textContent = `Загружено слов: ${allWords.length}`;
    saveState();
    alert('Добавлено новых слов: ' + added);
  }catch(e){
    console.error(e);
    alert('Ошибка при добавлении слов (см. консоль).');
  }
}

/* ========== Reset progress (clears lists and shows dua) ========== */
function resetProgress(){
  if(!confirm('Сбросить прогресс?')) return;
  try{ localStorage.removeItem(STORAGE_KEY); }catch(e){}
  // re-init in-memory structures
  orderRaw = allWords.map(w=>w.rawLine);
  shuffle(orderRaw);
  currentRaw = null;
  mistakes = [];
  corrects = [];
  mode = 'all';
  correctListDiv.innerHTML = '—';
  mistakeListDiv.innerHTML = '—';
  trainer.classList.add('hidden');
  loader.classList.remove('hidden');
  // show dua again
}

/* ========== Copy mistakes ==========
   copy rawLine list (as requested by user) */
function copyMistakes(){
  if(!mistakes.length) return alert('Ошибок нет.');
  const text = mistakes.join('\n');
  navigator.clipboard.writeText(text).then(()=> alert('Ошибки скопированы')).catch(()=> alert('Не удалось скопировать'));
}

/* ========== UI handlers (load, buttons) ========== */
didDuaBtn.addEventListener('click', () => {
  document.getElementById('intro').classList.add('hidden');
  // show loader or trainer depending on whether words have been loaded / restored
  if(allWords.length === 0){
    loader.classList.remove('hidden'); trainer.classList.add('hidden');
  } else {
    loader.classList.add('hidden'); trainer.classList.remove('hidden');
    // if we had currentRaw restored, show it, else start next
    if(currentRaw){
      const obj = allWords.find(w=>w.rawLine === currentRaw) || parseSingleLineToObj(currentRaw);
      arabicWordDiv.textContent = (obj && obj.arabicFull) ? obj.arabicFull : (currentRaw || '');
      updateProgress();
    } else {
      nextWord();
    }
  }
});

loadManualBtn.addEventListener('click', () => {
  const t = textInput.value;
  if(!t || !t.trim()) return alert('Вставьте список слов.');
  const { parsed, skipped } = improvedParseText(t);
  allWords = parsed.slice();
  countSpan.textContent = `Загружено слов: ${allWords.length}`;
  // initialize queue and show trainer
  orderRaw = allWords.map(w=>w.rawLine);
  shuffle(orderRaw);
  mistakes=[]; corrects=[]; currentRaw=null; mode='all';
  loader.classList.add('hidden'); trainer.classList.remove('hidden');
  renderLists(); saveState(); nextWord();
  if(skipped.length) console.warn('Skipped lines (no dash):', skipped.slice(0,30));
});

fetchFileBtn.addEventListener('click', async () => {
  try{
    const txt = await robustFetchWords();
    const { parsed, skipped } = improvedParseText(txt);
    allWords = parsed.slice();
    countSpan.textContent = `Загружено слов: ${allWords.length}`;
    // try restore if saved state exists; but still show dua until user clicks
    if(restoreStateAfterLoad()){
      loader.classList.add('hidden');
      // show intro to let user click "Я сделал дуа"
      trainer.classList.add('hidden');
      renderLists();
    } else {
      // initialize fresh
      orderRaw = allWords.map(w=>w.rawLine);
      shuffle(orderRaw);
      mistakes=[]; corrects=[]; currentRaw=null; mode='all';
      loader.classList.add('hidden');
      // show intro
      trainer.classList.add('hidden');
    }
    if(skipped.length) console.warn('Skipped lines (no dash):', skipped.slice(0,30));
    saveState();
  }catch(e){
    console.error(e);
    alert('Не удалось загрузить words.txt (см. консоль).');
  }
});

addNewBtn.addEventListener('click', addNewWords);
resetProgressBtn.addEventListener('click', resetProgress);
copyMistakesBtn.addEventListener('click', copyMistakes);

retryAllBtn.addEventListener('click', ()=> {
  // restart full run (without clearing storage) — rebuild order from allWords
  prepareOrder('all');
  currentRaw = null;
  mistakes = []; corrects = [];
  saveState();
  trainer.classList.remove('hidden'); loader.classList.add('hidden');
  nextWord();
});

workMistakesBtn.addEventListener('click', ()=> {
  if(!mistakes.length) return alert('Ошибок нет.');
  prepareOrder('mistakes');
  saveState();
  trainer.classList.remove('hidden'); loader.classList.add('hidden');
  // show trainer
  loader.classList.add('hidden'); trainer.classList.remove('hidden');
  nextWord();
});

/* ========== Restore on load (but show dua first) ========== */
(async function init(){
  try{
    // try to load words from server to know dictionary early (no automatic start)
    const txt = await robustFetchWords().catch(()=>null);
    if(txt){
      const { parsed } = improvedParseText(txt);
      allWords = parsed.slice();
      countSpan.textContent = `Загружено слов: ${allWords.length}`;
      // try restore state
      if(restoreStateAfterLoad()){
        // show dua screen (user must click to continue)
        document.getElementById('intro').classList.remove('hidden');
        loader.classList.add('hidden');
        trainer.classList.add('hidden');
        renderLists();
        updateProgress();
        return;
      } else {
        // no saved state -> show dua and loader to let user start
        orderRaw = allWords.map(w=>w.rawLine); shuffle(orderRaw);
        document.getElementById('intro').classList.remove('hidden');
        loader.classList.add('hidden'); trainer.classList.add('hidden');
        updateProgress();
        saveState();
        return;
      }
    } else {
      // no words fetched -> show loader so user can paste or fetch
      document.getElementById('intro').classList.remove('hidden');
      loader.classList.remove('hidden'); trainer.classList.add('hidden');
    }
  }catch(e){
    console.warn('init load failed', e);
    document.getElementById('intro').classList.remove('hidden');
    loader.classList.remove('hidden'); trainer.classList.add('hidden');
  }
})();

/* Save periodically and on leave */
window.addEventListener('beforeunload', saveState);
window.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='hidden') saveState(); });

</script>
</body>
</html>
