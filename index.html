<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Арабский тренажёр — выбор ответов</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;margin:20px;color:#111;background:#fff}
  #container{max-width:920px;margin:0 auto}
  .hidden{display:none}
  .button{padding:10px 14px;margin:6px;font-size:1rem;cursor:pointer;border-radius:6px;border:1px solid #bbb;background:#f6f6f6}
  h1{font-size:2rem;margin:0 0 6px}
  #progress{margin:12px 0;color:#333}
  #arabic-word{font-size:2.6rem;padding:20px 12px;background:#fff;border-radius:8px;border:1px solid #eee;text-align:center;direction:rtl;margin:12px 0;line-height:1.1}
  .choices{display:flex;flex-direction:column;gap:14px;margin-top:14px}
  .choice-btn{padding:18px;border-radius:12px;border:1px solid #e0e0e0;background:#fff;font-size:1.6rem;text-align:center;cursor:pointer}
  .choice-btn.correct{background:#d9f7e0;border-color:#8ad39f}
  .choice-btn.wrong{background:#ffdede;border-color:#ff8a8a}
  #lists{display:flex;gap:20px;margin-top:18px;flex-wrap:wrap}
  #correct-list,#mistake-list{flex:1 1 320px;min-height:80px;background:#fafafa;padding:10px;border-radius:6px;border:1px solid #eee;max-height:240px;overflow:auto}
  textarea{width:100%;height:140px;padding:8px;font-size:1rem}
  .controls-row{margin-top:12px}
  .small{font-size:0.95rem;color:#666}
  /* модалка */
  .overlay{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.38);display:flex;align-items:center;justify-content:center;z-index:10000;padding:20px}
  .modal{background:#fff;border-radius:8px;padding:22px;max-width:820px;width:100%;box-shadow:0 6px 30px rgba(0,0,0,0.25)}
  .modal h2{margin:0 0 8px;font-size:26px}
  .modal .label{font-size:16px;margin-bottom:8px}
  .modal .answer{font-weight:700;font-size:22px;direction:rtl;text-align:right}
  .modal .controls{display:flex;justify-content:flex-end;margin-top:14px}
  .close-btn{padding:8px 12px;border-radius:6px;border:1px solid #bbb;background:#f4f4f4;cursor:pointer}
  /* intro (дуа) */
  #intro {border:1px solid #eee;border-radius:10px;padding:20px;margin-bottom:16px;background:#fff}
  #intro blockquote{direction:rtl;font-size:2.2rem;margin:12px 0}
  @media(max-width:560px){ .choice-btn{font-size:1.25rem;padding:14px} #arabic-word{font-size:2.2rem;padding:14px} .modal .answer{font-size:18px} }
</style>
</head>
<body>
  <div id="container">
    <!-- Intro (дуа) -->
    <div id="intro">
      <h1>Перед началом тренировок</h1>
      <p>Дуа:</p>
      <blockquote>رَّبِّ زِدْنِى عِلْمًۭا</blockquote>
      <p>Перевод: «Господь мой! Приумножь мои знания»</p>
      <div style="margin-top:12px">
        <button id="did-dua" class="button">Я сделал дуа</button>
      </div>
    </div>

    <!-- Загрузка слов / управление -->
    <div id="loader" class="hidden">
      <p class="small">Список слов: формат — перевод(ы) через запятую - арабская_форма1 - арабская_форма2</p>
      <textarea id="text-input" placeholder="пример: жаловаться - اِشْتَكَى - يَشْتَكِي"></textarea>
      <div class="controls-row">
        <button id="load-manual" class="button">Загрузить вручную</button>
        <button id="fetch-file" class="button">Автозагрузить из words.txt</button>
        <span id="count" class="small"></span>
      </div>

      <div style="margin-top:8px">
        <button id="start-btn" class="button hidden">Начать тренировку</button>
        <!-- кнопки, которые пользователь просил рядом -->
        <button id="add-new-btn" class="button" title="Добавить новые слова из words.txt">Добавить новые слова</button>
        <button id="reset-progress-btn" class="button" title="Сбросить прогресс (очистка текущей сессии)">Сбросить прогресс</button>
        <button id="copy-mistakes-btn" class="button" title="Копировать ошибки в буфер">Копировать ошибки</button>
      </div>
    </div>

    <!-- Тренажёр -->
    <div id="trainer" class="hidden" aria-live="polite">
      <div id="progress"></div>
      <div id="arabic-word"></div>

      <div class="choices" id="choices">
        <button class="choice-btn" id="opt0"></button>
        <button class="choice-btn" id="opt1"></button>
        <button class="choice-btn" id="opt2"></button>
      </div>

      <div id="lists">
        <div>
          <h3>Правильно:</h3>
          <div id="correct-list">—</div>
        </div>
        <div>
          <h3>Ошибки:</h3>
          <div id="mistake-list">—</div>
        </div>
      </div>

      <div id="after" class="hidden" style="margin-top:14px">
        <button id="retry-all" class="button">Пройти заново (всю сессию)</button>
        <button id="work-mistakes" class="button hidden">Работа над ошибками</button>
      </div>
    </div>
  </div>

  <div id="modal-root"></div>

<script>
/* ====== Переменные ====== */
let allWords = [];      // { arabicFull, rusVariants:[], rawLine, pos }
let sessionWords = [];  // очередь для текущей сессии (объекты)
let mistakes = [];      // объекты
let corrects = [];
let currentIndex = 0;
let modalTimer = null;

/* ====== Элементы ====== */
const intro = document.getElementById('intro');
const didDuaBtn = document.getElementById('did-dua');

const loader = document.getElementById('loader');
const textInput = document.getElementById('text-input');
const loadManualBtn = document.getElementById('load-manual');
const fetchFileBtn = document.getElementById('fetch-file');
const startBtn = document.getElementById('start-btn');
const countSpan = document.getElementById('count');

const addNewBtn = document.getElementById('add-new-btn');
const resetProgressBtn = document.getElementById('reset-progress-btn');
const copyMistakesBtn = document.getElementById('copy-mistakes-btn');

const trainer = document.getElementById('trainer');
const progressDiv = document.getElementById('progress');
const arabicWordDiv = document.getElementById('arabic-word');
const optButtons = [document.getElementById('opt0'), document.getElementById('opt1'), document.getElementById('opt2')];

const correctListDiv = document.getElementById('correct-list');
const mistakeListDiv = document.getElementById('mistake-list');

const afterDiv = document.getElementById('after');
const retryAllBtn = document.getElementById('retry-all');
const workMistakesBtn = document.getElementById('work-mistakes');

const modalRoot = document.getElementById('modal-root');

/* ====== События intro ====== */
didDuaBtn.addEventListener('click', () => {
  // скрыть intro и показать loader (автозагрузка попытается выполниться)
  intro.classList.add('hidden');
  loader.classList.remove('hidden');
  // запустить автозагрузку words.txt (если доступен)
  autoFetchWords();
});

/* ====== Парсер и POS (эвристика) ====== */
function detectPOS(rusVars){
  const verbEndings = ['ться','ть','ить','еть','ать','овать','нуть','ять','тись','иться','оваться','ся'];
  for(const v of rusVars){
    const s = v.toLowerCase().trim();
    for(const e of verbEndings){
      if(s.endsWith(e)) return 'verb';
    }
  }
  return 'noun';
}

function parseText(text){
  allWords = text.split(/\r?\n/).map(l => l.trim()).filter(l => l).map(line => {
    const sep = line.search(/[-–—]/);
    const rusPart = sep !== -1 ? line.slice(0, sep).trim() : '';
    const arabPart = sep !== -1 ? line.slice(sep+1).trim() : '';
    const rusVars = rusPart ? rusPart.split(',').map(r => r.trim()).filter(r=>r) : [''];
    const arabFull = arabPart;
    const pos = detectPOS(rusVars);
    return { arabicFull: arabFull, rusVariants: rusVars, rawLine: line, pos };
  });
}

/* ====== Утилиты ====== */
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* ====== Загрузка / автозагрузка words.txt ====== */
function autoFetchWords(){
  // попытаемся получить words.txt автоматически
  fetch('words.txt').then(r => {
    if(!r.ok) throw new Error('no file');
    return r.text();
  }).then(txt => {
    textInput.value = txt;
    parseText(txt);
    countSpan.textContent = `Загружено слов: ${allWords.length}`;
    // показываем кнопки управления
    startBtn.classList.remove('hidden');
    // если хотим автоматически стартовать — можно раскомментировать:
    // startSession(false);
  }).catch(err => {
    // если нет файла — ничего страшного, пользователь загрузит вручную
    console.log('words.txt не найден или недоступен:', err);
  });
}

/* кнопка ручной загрузки */
loadManualBtn.addEventListener('click', () => {
  const text = textInput.value;
  if(!text.trim()) return alert('Вставьте список слов.');
  parseText(text);
  countSpan.textContent = `Загружено слов: ${allWords.length}`;
  startBtn.classList.remove('hidden');
});

/* кнопка загрузки words.txt вручную */
fetchFileBtn.addEventListener('click', () => {
  fetch('words.txt').then(r => {
    if(!r.ok) throw new Error('Ошибка загрузки');
    return r.text();
  }).then(txt => {
    textInput.value = txt;
    parseText(txt);
    countSpan.textContent = `Загружено слов: ${allWords.length}`;
    startBtn.classList.remove('hidden');
    alert('words.txt загружен');
  }).catch(e => { console.error(e); alert('Не удалось загрузить words.txt'); });
});

/* ====== Добавить новые слова (не сбрасывая сессию) ====== */
addNewBtn.addEventListener('click', () => {
  fetch('words.txt').then(r => {
    if(!r.ok) throw new Error('Ошибка загрузки');
    return r.text();
  }).then(txt => {
    const newLines = txt.split(/\r?\n/).map(l=>l.trim()).filter(l=>l);
    let added = 0;
    for(const ln of newLines){
      if(!allWords.some(w => w.rawLine === ln)){
        // парсим одну строку и добавляем
        const sep = ln.search(/[-–—]/);
        const rusPart = sep !== -1 ? ln.slice(0, sep).trim() : '';
        const arabPart = sep !== -1 ? ln.slice(sep+1).trim() : '';
        const rusVars = rusPart ? rusPart.split(',').map(r => r.trim()).filter(r=>r) : [''];
        const pos = detectPOS(rusVars);
        const obj = { arabicFull: arabPart, rusVariants: rusVars, rawLine: ln, pos };
        allWords.push(obj);
        // если сессия идёт — вставим новый объект в случайную позицию после текущего индекса
        if(sessionWords.length){
          const insertPos = currentIndex + 1 + Math.floor(Math.random() * (sessionWords.length - currentIndex + 1));
          sessionWords.splice(insertPos, 0, obj);
        }
        added++;
      }
    }
    countSpan.textContent = `Загружено слов: ${allWords.length}`;
    alert(`Добавлено новых слов: ${added}`);
  }).catch(e => { console.error(e); alert('Не удалось загрузить words.txt'); });
});

/* ====== Сессия: старт/логика ====== */
startBtn.addEventListener('click', () => startSession(false));
retryAllBtn.addEventListener('click', () => startSession(false));
workMistakesBtn.addEventListener('click', () => {
  if(mistakes.length === 0) return alert('Ошибок нет');
  startSession(true);
});

function startSession(useMistakes=false){
  corrects = [];
  if(!useMistakes){
    mistakes = [];
    sessionWords = allWords.slice();
  } else {
    sessionWords = mistakes.slice();
    mistakes = [];
  }
  if(sessionWords.length === 0){
    alert('Список слов пуст. Сначала загрузите words.txt или вставьте список.');
    return;
  }
  shuffle(sessionWords);
  currentIndex = 0;
  correctListDiv.innerHTML = '';
  mistakeListDiv.innerHTML = '';
  loader.classList.add('hidden');
  trainer.classList.remove('hidden');
  afterDiv.classList.add('hidden');
  showNext();
}

/* ====== Подбор неправильных вариантов (рандомно, в идеале той же POS) ====== */
function findDistractorsRandom(correctIndex, count){
  const correct = allWords[correctIndex];
  const candidatesSamePos = [];
  for(let i=0;i<allWords.length;i++){
    if(i === correctIndex) continue;
    if(allWords[i].pos === correct.pos) candidatesSamePos.push(i);
  }
  // если есть кандидаты той же POS, возьмём оттуда рандомно
  if(candidatesSamePos.length >= count){
    shuffle(candidatesSamePos);
    return candidatesSamePos.slice(0,count);
  }
  // иначе смешаем: добавим все samePos, затем добавим случайных из остальных
  const picks = candidatesSamePos.slice();
  const others = [];
  for(let i=0;i<allWords.length;i++){
    if(i === correctIndex) continue;
    if(!picks.includes(i)) others.push(i);
  }
  shuffle(others);
  while(picks.length < count && others.length) picks.push(others.shift());
  return picks.slice(0,count);
}

/* найти индекс item в allWords (по rawLine или полям) */
function findIndexInAll(item){
  let idx = allWords.findIndex(a => a.rawLine === item.rawLine);
  if(idx !== -1) return idx;
  idx = allWords.findIndex(a => a.arabicFull === item.arabicFull && a.rusVariants.join(',') === item.rusVariants.join(','));
  return idx;
}

/* показать следующий */
function showNext(){
  clearChoiceStyles();
  if(currentIndex >= sessionWords.length){
    progressDiv.textContent = `Готово! Пройдено ${sessionWords.length}/${sessionWords.length}, ошибок: ${mistakes.length}`;
    afterDiv.classList.remove('hidden');
    workMistakesBtn.classList.toggle('hidden', mistakes.length === 0);
    return;
  }
  const item = sessionWords[currentIndex];
  arabicWordDiv.textContent = item.arabicFull || '[нет арабского]';
  progressDiv.textContent = `${currentIndex+1}/${sessionWords.length} слов пройдено – ${mistakes.length} ошибок`;

  const correctText = item.rusVariants.join(', ');
  const mainIndex = findIndexInAll(item);
  const wrongIdxs = (mainIndex === -1) ? findDistractorsRandom(0,2) : findDistractorsRandom(mainIndex, 2);
  const wrongTexts = wrongIdxs.map(i => allWords[i] ? allWords[i].rusVariants.join(', ') : correctText);
  while(wrongTexts.length < 2) wrongTexts.push(correctText);

  const options = [correctText, wrongTexts[0], wrongTexts[1]];
  shuffle(options);
  optButtons.forEach((btn, idx) => {
    btn.textContent = options[idx] || '';
    btn.disabled = false;
    btn.classList.remove('correct','wrong');
    btn.dataset.correct = (options[idx] === correctText) ? '1' : '0';
  });
}

/* сброс стилей опций */
function clearChoiceStyles(){
  optButtons.forEach(b => { b.classList.remove('correct','wrong'); b.disabled = false; });
}

/* клики по вариантам */
optButtons.forEach(btn => {
  btn.addEventListener('click', e => {
    const chosen = e.currentTarget;
    const correct = chosen.dataset.correct === '1';
    optButtons.forEach(b => b.disabled = true);
    const cur = sessionWords[currentIndex];
    if(correct){
      chosen.classList.add('correct');
      correctListDiv.innerHTML = (correctListDiv.innerHTML.trim()==='—' ? '' : correctListDiv.innerHTML) + `<div>${escapeHtml(cur.arabicFull)} → ${escapeHtml(cur.rusVariants.join(', '))}</div>`;
      currentIndex++;
      setTimeout(() => showNext(), 700);
    } else {
      chosen.classList.add('wrong');
      mistakes.push(cur);
      mistakeListDiv.innerHTML = (mistakeListDiv.innerHTML.trim()==='—' ? '' : mistakeListDiv.innerHTML) + `<div>${escapeHtml(cur.arabicFull)} → ${escapeHtml(cur.rusVariants.join(', '))}</div>`;
      showWrongModal(cur.arabicFull, cur.rusVariants.join(', '), () => {
        currentIndex++;
        showNext();
      });
    }
  });
});

/* модалка при ошибке с Esc и автозакрытием 17с */
function showWrongModal(arabicText, ruText, onClose){
  closeModal();
  const overlay = document.createElement('div'); overlay.className = 'overlay';
  const modal = document.createElement('div'); modal.className = 'modal';
  modal.innerHTML = `<h2>Неправильно</h2>
    <div class="label">Правильный ответ:</div>
    <div class="answer">${escapeHtml(arabicText)} — ${escapeHtml(ruText)}</div>
    <div class="controls"><button id="modal-close-btn" class="close-btn">Закрыть (Esc)</button></div>`;
  overlay.appendChild(modal);
  modalRoot.appendChild(overlay);

  function cleanup(){ if(modalTimer){ clearTimeout(modalTimer); modalTimer = null; } document.removeEventListener('keydown', onKey); const b = document.getElementById('modal-close-btn'); if(b) b.removeEventListener('click', onBtn); if(overlay.parentNode) overlay.parentNode.removeChild(overlay); }
  function onKey(e){ if(e.key === 'Escape'){ cleanup(); if(typeof onClose === 'function') onClose(); } }
  function onBtn(){ cleanup(); if(typeof onClose === 'function') onClose(); }

  document.addEventListener('keydown', onKey);
  const btn = document.getElementById('modal-close-btn'); if(btn) btn.addEventListener('click', onBtn);
  modalTimer = setTimeout(() => { cleanup(); if(typeof onClose === 'function') onClose(); }, 17000);
}
function closeModal(){ modalRoot.innerHTML = ''; if(modalTimer){ clearTimeout(modalTimer); modalTimer = null; } }

/* ====== Копирование ошибок (оригинальные строки) ====== */
copyMistakesBtn.addEventListener('click', () => {
  if(mistakes.length === 0) return alert('Ошибок пока нет.');
  const text = mistakes.map(m => m.rawLine).join('\n');
  navigator.clipboard.writeText(text).then(() => {
    alert('Ошибки скопированы в буфер обмена.');
  }).catch(err => {
    console.error(err);
    alert('Не удалось скопировать ошибки (браузер не разрешил доступ).');
  });
});

/* ====== Сброс прогресса (локальный) ====== */
resetProgressBtn.addEventListener('click', () => {
  if(!confirm('Сбросить прогресс текущей сессии? Это очистит список ошибок и начнёт с начала.')) return;
  // очистим текущую сессию и ошибки, вернёмся на загрузку
  sessionWords = [];
  mistakes = [];
  corrects = [];
  currentIndex = 0;
  correctListDiv.innerHTML = '';
  mistakeListDiv.innerHTML = '';
  trainer.classList.add('hidden');
  loader.classList.remove('hidden');
  startBtn.classList.remove('hidden');
  countSpan.textContent = `Загружено слов: ${allWords.length}`;
});

/* ====== Вспомогательные ====== */
function escapeHtmlSimple(s){ return escapeHtml(s); } // алиас
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* ====== Автозапуск (если words.txt есть) - попытка ранее уже вызвана при наж. дуа,
           но на случай если пользователь сразу прошёл intro (или refresh) — попробуем */ 
// (этот автоFetch уже запускается при нажатии "Я сделал дуа")
/* ====== Конец скрипта ====== */
</script>
</body>
</html>
