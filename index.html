<!doctype html>

<html lang="ru">

<head>

<meta charset="utf-8"/>

<meta name="viewport" content="width=device-width,initial-scale=1"/>

<title>Тренажёр арабских слов — обновлённый</title>

<script defer src="https://cloud.umami.is/script.js" data-website-id="eb716e2e-5303-4a59-b38a-f4fd1d6d552a"></script>

<script type="module">

/* ---------- Firebase инициализация ---------- */

const firebaseConfig = {

  apiKey: "AIzaSyBM9YxHpD79wLzX33ya_6vZX1tC4d46Wfk",

  authDomain: "arabic-31a1a.firebaseapp.com",

  projectId: "arabic-31a1a",

  storageBucket: "arabic-31a1a.firebasestorage.app",

  messagingSenderId: "892431750830",

  appId: "1:892431750830:web:cbe977cc62d9851a4e7f3f"

};

try {

  const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js');

  const { getFirestore } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

  window.firebaseApp = initializeApp(firebaseConfig);

  window.firestore = getFirestore(window.firebaseApp);

  window.firebaseEnabled = true;

  window.firebaseModules = { doc: null, setDoc: null, getDoc: null, deleteDoc: null };

  const firestoreModule = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

  window.firebaseModules.doc = firestoreModule.doc;

  window.firebaseModules.setDoc = firestoreModule.setDoc;

  window.firebaseModules.getDoc = firestoreModule.getDoc;

  window.firebaseModules.deleteDoc = firestoreModule.deleteDoc;

  console.log('Firebase инициализирован');

} catch(e) {

  console.warn('Firebase не инициализирован:', e);

  window.firebaseEnabled = false;

}

</script>

<style>

  body{font-family:Arial,Helvetica,sans-serif;margin:18px;color:#111;background:#fff;max-width:980px}

  .dua{background:#fff;padding:14px;border-radius:10px;border:1px solid #eee;margin-bottom:12px}

  .arab{direction:rtl;font-size:2.2rem;font-weight:700;margin:8px 0;text-align:center}

  #arabic{direction:rtl;font-size:2.6rem;text-align:center;min-height:3.6em;padding:14px;border-radius:8px;border:1px solid #eee}

  .controls{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:12px}

  .controls-vertical{display:block;text-align:center;margin-top:10px}

  .controls-vertical .controls{justify-content:center}

  button{padding:10px 12px;border-radius:8px;border:1px solid #ccc;background:#f6f6f6;cursor:pointer}

  .btn-primary{background:#e6fff0;border-color:#b6f0c7}

  .btn-danger{background:#fff0f0;border-color:#f0b6b6}

  .small{font-size:0.95rem;color:#666;margin-top:8px;text-align:center}

  .hidden{display:none}

  input[type="text"]{width:100%;padding:10px;border-radius:8px;border:1px solid #ddd;box-sizing:border-box}

  .stats{display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin-bottom:8px}

  .stat{background:#fafafa;padding:8px 12px;border-radius:8px;border:1px solid #f0f0f0}

  .overlay{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:9999}

  .modal{background:#fff;padding:16px;border-radius:8px;max-width:720px;width:92%;box-shadow:0 8px 30px rgba(0,0,0,0.2)}

  .modal .pair{margin-top:8px}

</style>

</head>

<body>

  <h1>Тренажёр арабских слов</h1>

  <div id="screen-dua" class="dua">

    <div><strong>Перед началом тренировок</strong></div>

    <div class="arab">رَّبِّ زِدْنِى عِلْمًۭا</div>

    <div style="text-align:center;margin-top:6px">Перевод: «Господь мой! Приумножь мои знания»</div>

    <div style="text-align:center;margin-top:12px">

      <button id="btn-done-dua">Я сделал дуа</button>

    </div>

  </div>

  <div id="screen-main" class="hidden">

    <div class="stats">

      <div class="stat">Всего: <span id="stat-total">0</span></div>

      <div class="stat">Оконч. выучено: <span id="stat-mastered">0</span></div>

      <div class="stat">В очереди: <span id="stat-remaining">0</span></div>

      <div class="stat">Фаза: <span id="stat-phase">—</span></div>

    </div>

    <div id="arabic">…</div>

<!-- первая строка: Знаю / Не знаю -->

<div id="learn-controls" class="controls">

  <button id="btn-know" class="btn-primary">Знаю</button>

  <button id="btn-dont">Не знаю</button>

</div>

<!-- вторая строка: Сброс и Добавить -->

<div class="controls-vertical">

  <div class="controls">

    <button id="btn-reset" class="btn-danger">Сбросить прогресс</button>

    <button id="btn-add">Добавить новые слова</button>

  </div>

</div>

<div id="practice-area" class="hidden" style="margin-top:12px">

  <div style="margin-bottom:8px"><strong>Практика — введите перевод на русском:</strong></div>

  <input id="practice-input" type="text" autocomplete="off" placeholder="Введите перевод" />

  <div class="controls" style="margin-top:8px">

    <button id="practice-submit">Проверить</button>

    <button id="practice-skip">Пропустить</button>

  </div>

</div>

<div id="message" class="small" style="margin-top:12px"></div>

  </div>

  <div id="modal-root"></div>

<script>

/* ---------- Настройки ---------- */

const BATCH_SIZE = 10;

const SHOW_ANSWER_MS = 15000;

const STORAGE_KEY = (() => {

  const p = (location.pathname||'/').replace(/^\/|\/$/g,'').replace(/\//g,'_') || 'root';

  return `arabic_trainer_state_v1_${encodeURIComponent(location.hostname + '_' + p)}`;

})();

/* ---------- Firebase: Device ID ---------- */

function getDeviceId() {

  let deviceId = localStorage.getItem('device_id');

  if(!deviceId) {

    deviceId = 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

    localStorage.setItem('device_id', deviceId);

  }

  return deviceId;

}

const DEVICE_ID = getDeviceId();

/* ---------- Состояние ---------- */

let allWords = [];

let orderQueue = [];

let masteredFinal = [];

let practiceHistory = [];

let roundMastered = [];

let practiceAccum = [];

let practiceOrder = [];

let phase = 'learn';

let currentRaw = null;

let modalTimer = null;

/* ---------- DOM ---------- */

const screenDua = document.getElementById('screen-dua');

const screenMain = document.getElementById('screen-main');

const btnDoneDua = document.getElementById('btn-done-dua');

const statTotal = document.getElementById('stat-total');

const statMastered = document.getElementById('stat-mastered');

const statRemaining = document.getElementById('stat-remaining');

const statPhase = document.getElementById('stat-phase');

const arabicDiv = document.getElementById('arabic');

const learnControls = document.getElementById('learn-controls');

const btnKnow = document.getElementById('btn-know');

const btnDont = document.getElementById('btn-dont');

const btnAdd = document.getElementById('btn-add');

const btnReset = document.getElementById('btn-reset');

const messageDiv = document.getElementById('message');

const practiceArea = document.getElementById('practice-area');

const practiceInput = document.getElementById('practice-input');

const practiceSubmit = document.getElementById('practice-submit');

const practiceSkip = document.getElementById('practice-skip');

const modalRoot = document.getElementById('modal-root');

/* ---------- Утилиты ---------- */

function normalizeRu(s){

  if(!s && s!=='') return '';

  return String(s).trim().toLowerCase().replace(/ё/g,'е').replace(/\s+/g,' ');

}

function normalizeLine(l){ if(!l) return ''; return l.replace(/^\uFEFF/,'').replace(/[\u2010\u2011\u2012\u2013\u2014\u2015–—−]/g,'-').replace(/\s+/g,' ').trim(); }

function parseLine(raw){

  raw = normalizeLine(raw);

  const parts = raw.split(/[-–—]/).map(p=>p.trim()).filter(Boolean);

  const left = parts.length ? parts[0] : '';

  const right = parts.slice(1);

  const rus = left ? left.split(',').map(s=>s.trim()).filter(Boolean) : [];

  const arabParts = right.length ? right.join(' - ').split(/\s*-\s*/).map(s=>s.trim()).filter(Boolean) : [];

  return { rawLine: raw, rus, arabParts, arabFull: right.join(' - ') || '' };

}

function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }

function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[c]); }

/* ---------- Сравнение слов по содержимому ---------- */

function getWordContentHash(wordObj) {

  const arabContent = (wordObj.arabParts || []).join('|');

  const rusContent = (wordObj.rus || []).join('|');

  return `${arabContent}|||${rusContent}`;

}

function findWordByContent(allWords, targetWord) {

  const targetHash = getWordContentHash(targetWord);

  return allWords.find(w => getWordContentHash(w) === targetHash);

}

/* ---------- last-letter mistake detector ---------- */

function isLastCharMistake(userRaw, correctRaw){

  const u = normalizeRu(userRaw||'');

  const c = normalizeRu(correctRaw||'');

  if(!u || !c) return false;

  if(u === c) return false;

  if(u.length === c.length){

    if(u.slice(0, -1) === c.slice(0, -1) && u[u.length-1] !== c[c.length-1]) return true;

  }

  if(u.length === c.length - 1){

    if(u === c.slice(0, -1)) return true;

  }

  if(u.length === c.length + 1){

    if(u.slice(0, -1) === c) return true;

  }

  return false;

}

/* ---------- Save / Load / Clear (с Firebase) ---------- */

async function saveState(){

  const st = {

    allRaw: allWords.map(w=>w.rawLine),

    orderQueue: orderQueue.slice(),

    masteredFinal: masteredFinal.slice(),

    practiceHistory: practiceHistory.slice(),

    roundMastered: roundMastered.slice(),

    practiceAccum: practiceAccum.slice(),

    practiceOrder: practiceOrder.slice(),

    phase, currentRaw,

    timestamp: Date.now()

  };

  try{

    localStorage.setItem(STORAGE_KEY, JSON.stringify(st));

    localStorage.setItem(STORAGE_KEY + '_backup', JSON.stringify(st));

  }catch(e){ console.warn('localStorage save failed', e); }

  if(window.firebaseEnabled && window.firestore && window.firebaseModules){

    try{

      const firestoreKey = `${DEVICE_ID}_${STORAGE_KEY}`;

      const docRef = window.firebaseModules.doc(window.firestore, 'progress', firestoreKey);

      await window.firebaseModules.setDoc(docRef, st, { merge: true });

      console.log('Сохранено в Firestore');

    }catch(e){ console.warn('Firestore save failed:', e); }

  }

}

async function loadState(){

  try{

    const raw = localStorage.getItem(STORAGE_KEY);

    if(raw){

      const st = JSON.parse(raw);

      if(st.timestamp && (Date.now() - st.timestamp) < 24*60*60*1000){

        return st;

      }

    }

  }catch(e){ console.warn('localStorage load failed', e); }

  if(window.firebaseEnabled && window.firestore && window.firebaseModules){

    try{

      const firestoreKey = `${DEVICE_ID}_${STORAGE_KEY}`;

      const docRef = window.firebaseModules.doc(window.firestore, 'progress', firestoreKey);

      const docSnap = await window.firebaseModules.getDoc(docRef);

      if(docSnap.exists()){

        const data = docSnap.data();

        console.log('Загружено из Firestore');

        try{

          localStorage.setItem(STORAGE_KEY, JSON.stringify(data));

          localStorage.setItem(STORAGE_KEY + '_backup', JSON.stringify(data));

        }catch(e){}

        return data;

      }

    }catch(e){

      console.warn('Firestore load failed:', e);

      try{

        const backup = localStorage.getItem(STORAGE_KEY + '_backup');

        if(backup) return JSON.parse(backup);

      }catch(e){}

    }

  }

  try{

    const backup = localStorage.getItem(STORAGE_KEY + '_backup');

    if(backup) return JSON.parse(backup);

  }catch(e){}

  return null;

}

async function clearState(){

  try{

    localStorage.removeItem(STORAGE_KEY);

    localStorage.removeItem(STORAGE_KEY + '_backup');

  }catch(e){}

  if(window.firebaseEnabled && window.firestore && window.firebaseModules){

    try{

      const firestoreKey = `${DEVICE_ID}_${STORAGE_KEY}`;

      const docRef = window.firebaseModules.doc(window.firestore, 'progress', firestoreKey);

      await window.firebaseModules.deleteDoc(docRef);

      console.log('Удалено из Firestore');

    }catch(e){ console.warn('Firestore delete failed:', e); }

  }

}

/* ---------- robust fetch ---------- */

async function robustFetchWords(){

  const timestamp = Date.now();

  const tries = ['words.txt','./words.txt'];

  try{ tries.push(location.pathname.replace(/\/[^/]*$/,'/') + 'words.txt'); }catch(e){}

  for(const p of tries){

    try{ const r = await fetch(p + '?_' + timestamp, {cache: 'no-store'}); if(r.ok) return await r.text(); }catch(e){}

  }

  try{

    const user = location.hostname.split('.')[0] || '';

    const repo = (location.pathname.split('/').filter(Boolean)[0] || '');

    if(user && repo){

      const raw = `https://raw.githubusercontent.com/${user}/${repo}/main/words.txt`;

      const r = await fetch(raw + '?_' + timestamp, {cache: 'no-store'});

      if(r.ok) return await r.text();

    }

  }catch(e){}

  throw new Error('Не удалось загрузить words.txt');

}

/* ---------- Инициализация словаря (с сохранением прогресса) ---------- */

async function initDictionary(){

  const st = await loadState();

  let serverWords = [];

  let serverWordsByRaw = new Map();

  let serverRawSet = new Set();

  try{

    const txt = await robustFetchWords();

    const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);

    serverWords = lines.map(parseLine);

    serverWords.forEach(w => {

      serverWordsByRaw.set(w.rawLine, w);

      serverRawSet.add(w.rawLine);

    });

  }catch(e){ console.warn('Не удалось загрузить words.txt:', e); }

  if(st && Array.isArray(st.allRaw) && st.allRaw.length){

    allWords = st.allRaw.map(raw => {

      const parsed = parseLine(raw);

      return { rawLine: raw, ...parsed };

    });

    if(serverWords.length > 0 && serverRawSet.size > 0){

      const existingWordsByRaw = new Map();

      allWords.forEach(w => {

        existingWordsByRaw.set(w.rawLine, w);

      });

      allWords = allWords.filter(w => {

        return serverRawSet.size === 0 || serverRawSet.has(w.rawLine);

      });

      if(serverRawSet.size > 0){

        orderQueue = (Array.isArray(st.orderQueue) ? st.orderQueue.filter(r => serverRawSet.has(r) || !serverRawSet.size) : []);

        masteredFinal = (Array.isArray(st.masteredFinal) ? st.masteredFinal.filter(r => serverRawSet.has(r) || !serverRawSet.size) : []);

        practiceHistory = (Array.isArray(st.practiceHistory) ? st.practiceHistory.filter(r => serverRawSet.has(r) || !serverRawSet.size) : []);

        roundMastered = (Array.isArray(st.roundMastered) ? st.roundMastered.filter(r => serverRawSet.has(r) || !serverRawSet.size) : []);

        practiceAccum = (Array.isArray(st.practiceAccum) ? st.practiceAccum.filter(r => serverRawSet.has(r) || !serverRawSet.size) : []);

        practiceOrder = (Array.isArray(st.practiceOrder) ? st.practiceOrder.filter(r => serverRawSet.has(r) || !serverRawSet.size) : []);

      } else {

        orderQueue = st.orderQueue || [];

        masteredFinal = st.masteredFinal || [];

        practiceHistory = st.practiceHistory || [];

        roundMastered = st.roundMastered || [];

        practiceAccum = st.practiceAccum || [];

        practiceOrder = st.practiceOrder || [];

      }

      const changedWords = [];

      allWords.forEach((existingWord, index) => {

        if(serverRawSet.has(existingWord.rawLine)){

          const serverWord = serverWordsByRaw.get(existingWord.rawLine);

          if(getWordContentHash(existingWord) !== getWordContentHash(serverWord)){

            const updatedWord = { rawLine: serverWord.rawLine, ...serverWord };

            allWords[index] = updatedWord;

            changedWords.push(serverWord.rawLine);

          }

        }

      });

      changedWords.forEach(rawLine => {

        masteredFinal = masteredFinal.filter(r => r !== rawLine);

        practiceHistory = practiceHistory.filter(r => r !== rawLine);

        roundMastered = roundMastered.filter(r => r !== rawLine);

        practiceAccum = practiceAccum.filter(r => r !== rawLine);

        practiceOrder = practiceOrder.filter(r => r !== rawLine);

        if(!orderQueue.includes(rawLine)){

          orderQueue.push(rawLine);

        }

      });

    } else {

      console.warn('Сервер не вернул слова, используем сохранённые данные');

      orderQueue = st.orderQueue || [];

      masteredFinal = st.masteredFinal || [];

      practiceHistory = st.practiceHistory || [];

      roundMastered = st.roundMastered || [];

      practiceAccum = st.practiceAccum || [];

      practiceOrder = st.practiceOrder || [];

    }

    phase = st.phase || 'learn';

    currentRaw = (st.currentRaw && (serverRawSet.size === 0 || serverRawSet.has(st.currentRaw))) ? st.currentRaw : null;

  } else {

    if(serverWords.length > 0){

      allWords = serverWords.slice();

      masteredFinal = []; practiceHistory = []; roundMastered = []; practiceAccum = []; practiceOrder = [];

      phase = 'learn'; currentRaw = null;

      orderQueue = allWords.map(w=>w.rawLine);

      shuffle(orderQueue);

    } else {

      console.error('Нет данных для инициализации');

      showMessage('Не удалось загрузить слова. Проверьте подключение к интернету.');

      return;

    }

  }

  updateStats();

  await saveState();

}

/* ---------- UI helpers ---------- */

function updateStats(){

  statTotal.textContent = allWords.length;

  statMastered.textContent = masteredFinal.length;

  statRemaining.textContent = Array.isArray(orderQueue) ? orderQueue.length : 0;

  statPhase.textContent = phase === 'learn' ? 'Заучивание' : (phase === 'practice' ? 'Практика' : '—');

}

function showMessage(t){ messageDiv.textContent = t || ''; }

/* ---------- Заучивание ---------- */

async function showNextLearn(){

  phase = 'learn';

  learnControls.classList.remove('hidden');

  practiceArea.classList.add('hidden');

  updateStats();

  if(orderQueue.length === 0){

    if(practiceAccum.length >= BATCH_SIZE){

      startPractice();

      return;

    }

    arabicDiv.textContent = 'Очередь пуста.';

    showMessage('Добавьте слова или сбросьте прогресс.');

    await saveState();

    return;

  }

  currentRaw = orderQueue[0];

  const obj = allWords.find(w=>w.rawLine===currentRaw) || {rawLine:currentRaw, rus:[], arabParts:[], arabFull:''};

  arabicDiv.textContent = obj.arabFull || (obj.arabParts||[]).join(' - ') || '[нет арабского]';

  showMessage('Нажмите «Знаю» или «Не знаю».');

  await saveState();

  updateStats();

}

/* ---------- Кнопки заучивания ---------- */

btnKnow.addEventListener('click', async () => {

  if(!currentRaw) return;

  orderQueue.shift();

  if(!roundMastered.includes(currentRaw)) roundMastered.push(currentRaw);

  if(!practiceAccum.includes(currentRaw)) practiceAccum.push(currentRaw);

  currentRaw = null;

  await saveState();

  updateStats();

  if (practiceAccum.length >= BATCH_SIZE) {

    startPractice();

  } else {

    await showNextLearn();

  }

});

btnDont.addEventListener('click', async () => {

  if(!currentRaw) return;

  orderQueue.shift();

  if(!practiceAccum.includes(currentRaw)) practiceAccum.push(currentRaw);

  const obj = allWords.find(w=>w.rawLine===currentRaw) || parseLine(currentRaw);

  showDontKnowModal(obj);

  currentRaw = null;

  await saveState();

  updateStats();

});

/* ---------- Modal: "Не знаю" ---------- */

function showDontKnowModal(obj){

  closeModal();

  const overlay = document.createElement('div'); overlay.className='overlay';

  const modal = document.createElement('div'); modal.className='modal';

  let html = '';

  const ar = obj.arabParts && obj.arabParts.length ? obj.arabParts : (obj.arabFull?obj.arabFull.split(/\s*-\s*/).map(s=>s.trim()):[]);

  if(obj.rus.length && ar.length && obj.rus.length === ar.length){

    for(let i=0;i<obj.rus.length;i++) html += `<div class="pair">${escapeHtml(obj.rus[i])} — <span style="direction:rtl">${escapeHtml(ar[i])}</span></div>`;

  } else {

    const arabAll = ar.join(' - ');

    for(const r of obj.rus.length?obj.rus:['']) html += `<div class="pair">${escapeHtml(r)} — <span style="direction:rtl">${escapeHtml(arabAll)}</span></div>`;

  }

  modal.innerHTML = `<div><strong>Перевод (показывается 15 с)</strong></div><div style="margin-top:8px">${html}</div>`;

  overlay.appendChild(modal);

  modalRoot.appendChild(overlay);

  modalTimer = setTimeout(()=>{

    closeModal();

    if(practiceAccum.length >= BATCH_SIZE){

      startPractice();

    } else {

      showNextLearn();

    }

  }, SHOW_ANSWER_MS);

}

/* ---------- Modal: практика — при ошибке (и для почти-верно) ---------- */

function showPracticeAnswerModal(obj, title = 'Правильный ответ', autoClose = true, onClose = null){

  closeModal();

  const overlay = document.createElement('div'); overlay.className='overlay';

  const modal = document.createElement('div'); modal.className='modal';

  let html = '';

  const ar = obj.arabParts && obj.arabParts.length ? obj.arabParts : (obj.arabFull?obj.arabFull.split(/\s*-\s*/).map(s=>s.trim()):[]);

  if(obj.rus.length && ar.length && obj.rus.length === ar.length){

    for(let i=0;i<obj.rus.length;i++) html += `<div class="pair">${escapeHtml(obj.rus[i])} — <span style="direction:rtl">${escapeHtml(ar[i])}</span></div>`;

  } else {

    const arabAll = ar.join(' - ');

    for(const r of obj.rus.length?obj.rus:['']) html += `<div class="pair">${escapeHtml(r)} — <span style="direction:rtl">${escapeHtml(arabAll)}</span></div>`;

  }

  modal.innerHTML = `<div><strong>${escapeHtml(title)}</strong></div><div style="margin-top:8px">${html}</div><div style="text-align:right;margin-top:12px"><button id="modal-close" class="button">Закрыть (Esc)</button></div>`;

  overlay.appendChild(modal);

  modalRoot.appendChild(overlay);

  function cleanup(){ if(modalTimer){ clearTimeout(modalTimer); modalTimer=null; } document.removeEventListener('keydown', onKey); overlay.removeEventListener('click', onOverlay); const b=document.getElementById('modal-close'); if(b) b.removeEventListener('click', onBtn); if(overlay.parentNode) overlay.parentNode.removeChild(overlay); practiceInput.focus(); }

  function onKey(e){ if(e.key==='Escape') onBtn(); }

  function onOverlay(e){ if(e.target===overlay) onBtn(); }

  function onBtn(){ cleanup(); if(onClose) onClose(); else showNextPractice(); }

  document.addEventListener('keydown', onKey);

  overlay.addEventListener('click', onOverlay);

  const btn = document.getElementById('modal-close'); if(btn) btn.addEventListener('click', onBtn);

  if(autoClose) modalTimer = setTimeout(()=>{ onBtn(); }, SHOW_ANSWER_MS);

}

/* ---------- Практика: старт, порядок ---------- */

function startPractice(){

  phase = 'practice';

  learnControls.classList.add('hidden');

  practiceArea.classList.remove('hidden');

  let newWords = practiceAccum.slice(0, BATCH_SIZE);

  let practiceWords = masteredFinal.filter(word => !roundMastered.includes(word));

  practiceOrder = newWords.concat(practiceWords);

  if(practiceWords.length > 1) {

    const shuffledMastered = practiceWords.slice();

    shuffle(shuffledMastered);

    practiceOrder = newWords.concat(shuffledMastered);

  }

  practiceAccum = [];

  roundMastered = [];

  updateStats();

  showNextPractice();

  saveState().catch(e => console.warn('Save failed:', e));

}

/* ---------- showNextPractice ---------- */

async function showNextPractice(){

  if(!practiceOrder || practiceOrder.length === 0) {

    if(roundMastered.length > 0) {

      const notMastered = practiceOrder.filter(word => !roundMastered.includes(word));

      orderQueue = orderQueue.concat(notMastered);

    }

    phase = 'learn';

    learnControls.classList.remove('hidden');

    practiceArea.classList.add('hidden');

    await saveState();

    updateStats();

    await showNextLearn();

    return;

  }

  currentRaw = practiceOrder.shift();

  const obj = allWords.find(w=>w.rawLine===currentRaw) || parseLine(currentRaw);

  arabicDiv.textContent = obj.arabFull || (obj.arabParts||[]).join(' - ') || '[нет арабского]';

  practiceInput.value = '';

  practiceInput.focus();

  updateStats();

}

/* ---------- Практика: проверка (Enter и кнопка) ---------- */

function enablePracticeControls(){ practiceSubmit.disabled=false; practiceSkip.disabled=false; practiceInput.disabled=false; practiceInput.focus(); }

function disablePracticeControls(){ practiceSubmit.disabled=true; practiceSkip.disabled=true; practiceInput.disabled=true; }

practiceSubmit.addEventListener('click', async () => {

  if(!currentRaw) return;

  disablePracticeControls();

  try{

    const val = (practiceInput.value||'').trim();

    if(!val){ enablePracticeControls(); return; }

    const obj = allWords.find(w=>w.rawLine===currentRaw) || parseLine(currentRaw);

    const userNorm = normalizeRu(val);

    const exact = (obj.rus||[]).some(r => normalizeRu(r) === userNorm);

    const almost = !exact && (obj.rus||[]).some(r => isLastCharMistake(userNorm, normalizeRu(r)));

    const isFromMastered = masteredFinal.includes(currentRaw);

    if(exact){

      if(!roundMastered.includes(currentRaw)) roundMastered.push(currentRaw);

      if(!masteredFinal.includes(currentRaw)) masteredFinal.push(currentRaw);

      if(!practiceHistory.includes(currentRaw)) practiceHistory.push(currentRaw);

      showMessage('Верно — отмечено как окончательно выученное.');

      await saveState();

      updateStats();

      currentRaw = null;

      enablePracticeControls();

      showNextPractice();

    } else if(almost){

      if(!roundMastered.includes(currentRaw)) roundMastered.push(currentRaw);

      if(!masteredFinal.includes(currentRaw)) masteredFinal.push(currentRaw);

      if(!practiceHistory.includes(currentRaw)) practiceHistory.push(currentRaw);

      await saveState();

      updateStats();

      showPracticeAnswerModal(obj, 'Мелкая ошибка — засчитано', true);

      currentRaw = null;

      enablePracticeControls();

    } else {

      if(isFromMastered) {

        practiceOrder.unshift(currentRaw);

        await saveState();

        updateStats();

        showPracticeAnswerModal(obj, 'Неправильно', true, () => {

          currentRaw = null;

          enablePracticeControls();

          showNextPractice();

        });

      } else {

        orderQueue.unshift(currentRaw);

        if(masteredFinal.includes(currentRaw)) {

          masteredFinal = masteredFinal.filter(r=>r!==currentRaw);

          practiceHistory = practiceHistory.filter(r=>r!==currentRaw);

        }

        await saveState();

        updateStats();

        showPracticeAnswerModal(obj, 'Неправильно', true);

        currentRaw = null;

        enablePracticeControls();

      }

    }

  }catch(e){ console.error(e); enablePracticeControls(); }

});

practiceInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); practiceSubmit.click(); } });

practiceSkip.addEventListener('click', async ()=>{

  if(!currentRaw) return;

  const isFromMastered = masteredFinal.includes(currentRaw);

  if(isFromMastered) {

    practiceOrder.unshift(currentRaw);

    await saveState();

    updateStats();

    currentRaw = null;

    showNextPractice();

  } else {

    orderQueue.unshift(currentRaw);

    if(masteredFinal.includes(currentRaw)) {

      masteredFinal = masteredFinal.filter(r => r !== currentRaw);

      practiceHistory = practiceHistory.filter(r => r !== currentRaw);

    }

    await saveState();

    updateStats();

    currentRaw = null;

    showNextPractice();

  }

});

/* ---------- Добавить новые слова (только по кнопке) ---------- */

btnAdd.addEventListener('click', async () => {

  try{

    const txt = await robustFetchWords();

    const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);

    const serverWords = lines.map(parseLine);

    const existingByRawLine = new Set();

    allWords.forEach(w => {

      existingByRawLine.add(w.rawLine);

    });

    let added = 0;

    for(const newWord of serverWords){

      if(!existingByRawLine.has(newWord.rawLine)){

        allWords.push(newWord);

        orderQueue.push(newWord.rawLine);

        existingByRawLine.add(newWord.rawLine);

        added++;

      }

    }

    if(added) {

      shuffle(orderQueue);

      await saveState();

      updateStats();

      alert('Добавлено новых слов: ' + added);

    } else {

      alert('Новых слов не найдено');

    }

  }catch(e){ alert('Ошибка: '+e.message); }

});

/* ---------- Сброс прогресса с подтверждением ---------- */

function showResetModal() {

  closeModal();

  const overlay = document.createElement('div'); overlay.className = 'overlay';

  const modal = document.createElement('div'); modal.className = 'modal';

  modal.innerHTML = `

    <div><strong>Подтверждение сброса</strong></div>

    <div style="margin-top:12px">Вы уверены? Все выученные слова и прогресс будут потеряны. Это действие нельзя отменить.</div>

    <div style="text-align:right;margin-top:16px">

      <button id="modal-cancel" style="margin-right:8px">Отмена</button>

      <button id="modal-confirm" class="btn-danger">Да, сбросить</button>

    </div>

  `;

  overlay.appendChild(modal);

  modalRoot.appendChild(overlay);

  function cleanup() {

    document.removeEventListener('keydown', onKey);

    overlay.removeEventListener('click', onOverlay);

    const cancelBtn = document.getElementById('modal-cancel');

    const confirmBtn = document.getElementById('modal-confirm');

    if (cancelBtn) cancelBtn.removeEventListener('click', onCancel);

    if (confirmBtn) confirmBtn.removeEventListener('click', onConfirm);

    if(overlay.parentNode) overlay.parentNode.removeChild(overlay);

  }

  function onKey(e) { if (e.key === 'Escape') onCancel(); }

  function onOverlay(e) { if (e.target === overlay) onCancel(); }

  function onCancel() { cleanup(); }

  async function onConfirm() {

    cleanup();

    await clearState();

    orderQueue = allWords.map(w=>w.rawLine); shuffle(orderQueue);

    masteredFinal = []; practiceHistory = []; roundMastered = []; practiceAccum = []; practiceOrder = []; phase='learn'; currentRaw=null;

    screenMain.classList.add('hidden'); screenDua.classList.remove('hidden');

    updateStats();

    showMessage('Прогресс сброшен.');

  }

  document.addEventListener('keydown', onKey);

  overlay.addEventListener('click', onOverlay);

  document.getElementById('modal-cancel').addEventListener('click', onCancel);

  document.getElementById('modal-confirm').addEventListener('click', onConfirm);

}

btnReset.addEventListener('click', showResetModal);

/* ---------- "Я сделал дуа" ---------- */

btnDoneDua.addEventListener('click', async ()=>{

  screenDua.classList.add('hidden');

  screenMain.classList.remove('hidden');

  if(!allWords.length){

    try{

      await initDictionary();

    }catch(e){

      console.warn('initDictionary failed:', e);

      showMessage('Не удалось загрузить список слов — проверьте подключение. Продолжаем работу.');

    }

  }

  if(phase==='practice' && practiceOrder && practiceOrder.length){

    learnControls.classList.add('hidden');

    practiceArea.classList.remove('hidden');

    showNextPractice();

  } else {

    practiceArea.classList.add('hidden');

    learnControls.classList.remove('hidden');

    if(currentRaw){

      const o = allWords.find(w=>w.rawLine===currentRaw);

      arabicDiv.textContent = (o && (o.arabFull || o.arabParts.join(' - ')))||currentRaw;

    } else {

      showNextLearn();

    }

  }

});

/* ---------- init ---------- */

(async function bootstrap(){

  try{ 

    await initDictionary();

    // Всегда показываем дуа при каждом запуске

    screenDua.classList.remove('hidden');

    screenMain.classList.add('hidden');

  }catch(e){ 

    console.error(e);

    screenDua.classList.remove('hidden');

    screenMain.classList.add('hidden');

  }

})();

window.addEventListener('beforeunload', () => { saveState().catch(e => console.warn('Save on unload failed:', e)); });

window.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='hidden') saveState().catch(e => console.warn('Save on visibility change failed:', e)); });

/* ---------- Modal helper ---------- */

function closeModal(){ modalRoot.innerHTML=''; if(modalTimer){ clearTimeout(modalTimer); modalTimer=null; } }

</script>

</body>

</html>
